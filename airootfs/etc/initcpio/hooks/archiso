#!/usr/bin/ash
#
# SPDX-License-Identifier: GPL-3.0-or-later

# args: source, newroot, mountpoint
_mnt_overlayfs() {
    local src="${1}"
    local upperdir="${2}"
    local workdir="${3}"
    local newroot="${4}"
    mkdir -p "/run/archiso/cowspace/${cow_directory}/upperdir" "/run/archiso/cowspace/${cow_directory}/workdir"
    mount -t overlay -o \
        "lowerdir=${src},upperdir=${upperdir},workdir=${workdir}" \
        airootfs "${newroot}"
}

# args: device, mountpoint, flags, opts
_mnt_dev() {
    local dev="${1}"
    local mnt="${2}"
    local flg="${3}"
    local opts="${4}"
    local resolved_dev

    msg ":: Mounting '${dev}' to '${mnt}'"

    while ! resolved_dev="$(rootdelay="${rootdelay:-30}" resolve_device "${dev}")"; do
        echo "ERROR: '${dev}' device did not show up after ${rootdelay:-30} seconds..."
        echo "   Falling back to interactive prompt"
        echo "   You can try to fix the problem manually, log out when you are finished"
        launch_interactive_shell
    done

    # If the tag is supported by mount, pass it as is. Otherwise, use the resolved device path.
    case "${dev}" in
        'UUID='* | 'LABEL='* | 'PARTUUID='* | 'PARTLABEL='*) : ;;
        *) dev="${resolved_dev}" ;;
    esac
    if mount --mkdir -o "${opts}" "${flg}" "${dev}" "${mnt}"; then
        msg ":: Device '${dev}' mounted successfully."
    else
        echo "ERROR; Failed to mount '${dev}'"
        echo "   Falling back to interactive prompt"
        echo "   You can try to fix the problem manually, log out when you are finished"
        launch_interactive_shell
    fi
}

run_hook() {
    [ -z "${archisodevice}" ] && archisodevice="/dev/disk/by-label/${archisolabel}"

    [ -z "${copytoram}" ] && copytoram="n"
    [ -z "${copytoram_size}" ] && copytoram_size="75%"

    [ -z "${cow_spacesize}" ] && cow_spacesize="256M"
    [ -z "${cow_directory}" ] && cow_directory="persistent_${archisolabel}"

    # set mount handler for archiso
    export mount_handler="archiso_mount_handler"
}

# This function is called normally from init script, but it can be called
# as chain from other mount handlers.
# args: /path/to/newroot
archiso_mount_handler() {
    local newroot="${1}"
    local fs_img
    local img_fullname
    local img_loopdev

    if mountpoint -q "/run/archiso/bootmnt"; then
        echo "ERROR: can't mount root on /run/archiso/bootmnt"
        launch_interactive_shell
    fi
    _mnt_dev "${archisodevice}" "/run/archiso/bootmnt" "-r" "defaults"

    fs_img="/run/archiso/bootmnt/linux/airootfs.erofs"
    if [ ! -f "${fs_img}" ]; then
        echo "ERROR: no root file system image found"
        launch_interactive_shell
    fi

    if [ "${copytoram}" = "y" ]; then
        msg ":: Mounting /run/archiso/copytoram (tmpfs) filesystem, size=${copytoram_size}"
        mount --mkdir -t tmpfs -o "size=${copytoram_size}",mode=0755 copytoram /run/archiso/copytoram
        img_fullname="${fs_img##*/}"
        if command -v pv >/dev/null 2>&1; then
            pv "${fs_img}" >"/run/archiso/copytoram/${img_fullname}"
        else
            cp "${fs_img}" "/run/archiso/copytoram/${img_fullname}"
        fi
        img_loopdev="$(losetup --find --show --read-only -- "/run/archiso/copytoram/${img_fullname}")"
    else
        img_loopdev="$(losetup --find --show --read-only -- "${fs_img}")"
    fi

    msg ":: Mounting /run/archiso/cowspace (tmpfs) filesystem, size=${cow_spacesize}..."
    mount --mkdir -t tmpfs -o "size=${cow_spacesize}",mode=0755 cowspace /run/archiso/cowspace
    mkdir -p "/run/archiso/cowspace/${cow_directory}"/{upperdir,workdir}

    _mnt_dev "${img_loopdev}" "/run/archiso/airootfs" "-r" "defaults"
    _mnt_overlayfs \
        "/run/archiso/airootfs" \
        "/run/archiso/cowspace/${cow_directory}/upperdir" \
        "/run/archiso/cowspace/${cow_directory}/workdir" \
        "${newroot}"
}

# vim: set ft=sh:
